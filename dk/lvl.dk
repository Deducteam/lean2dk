Lvl: Type.

def z: Lvl.
def s: Lvl -> Lvl.
def max: Lvl -> Lvl -> Lvl.
def imax: Lvl -> Lvl -> Lvl.

def eq: Lvl -> Lvl -> bool.Bool.
[ n ] eq n n --> bool.true.
[] eq _ _ --> bool.false.

Set: Type.
nil: Set.
singleton: Lvl -> Set.
defac union [Set].
def cons: Lvl -> Set -> Set.
[l, s] cons s l --> union (singleton s) l.

def add: Lvl -> Set -> Set.

def iteset: bool.Bool -> Set -> Set -> Set.
[n] iteset bool.true n _ --> n.
[n] iteset bool.false _ n --> n.

[l] add l nil --> cons l nil.
[l, l', ls] add l (union (singleton l') ls) --> iteset (eq l l') (cons l' ls) (cons l' (add l ls)).

def merge: Set -> Set -> Set.
[l] merge nil l --> l.
[l1, l2, n] merge (union (singleton n) l1) l2 --> add n (merge l1 l2).

def in: Lvl -> Set -> bool.Bool.
[] in _ nil --> bool.false.
[n, m, l] in n (union (singleton m) l) --> bool.or (eq n m) (in n l).

def subset: Set -> Set -> bool.Bool.
[] subset nil _ --> bool.true.
[n, q, l] subset (union (singleton n) q) l --> bool.and (in n l) (subset q l).

def eqset: Set -> Set -> bool.Bool.
[l1, l2] eqset l1 l2 --> bool.and (subset l1 l2) (subset l2 l1).

def leqset: Set -> Set -> bool.Bool.

[] leqset nil _ --> bool.true.
[] leqset (union (singleton _) _) nil --> bool.false.
[n, m, l1, l2] leqset (union (singleton n) l1) (union (singleton m) l2) --> bool.and (eq n m) (leqset l1 l2).

def lqset: Set -> Set -> bool.Bool.
[l1, l2] lqset l1 l2 --> bool.and (leqset l1 l2) (bool.not (eqset l1 l2)).
