Univ : lvl.Lvl -> Type.

Sort : s:lvl.Lvl -> Univ (lvl.s s).

def El : s:lvl.Lvl -> Univ s -> Type.

Pi : s1:lvl.Lvl -> s2:lvl.Lvl -> s3:lvl.Lvl -> t:Univ s1 -> (El s1 t -> Univ s2) -> Univ s3.
[s1, s2, s3, t, f] El s3 (Pi s1 s2 s3 t f) --> x:(El s1 t) -> (El s2 (f x)).

[l] El _ (Sort l) --> Univ l.

(; --- universe level normalization rewrite rules --- ;)

[] lvl.z --> normalize.maxS sublvl.nil.

[] lvl.s (normalize.maxS sublvl.nil) --> 
normalize.maxS (sublvl.cons (sublvl.b lvl.nil (nat.s nat.z)) sublvl.nil).
[u, q] lvl.s (normalize.maxS (sublvl.union (sublvl.singleton u) q)) --> 
normalize.maxS (sublvl.s (sublvl.cons u q)).

[l, l'] lvl.max (normalize.maxS l) (normalize.maxS l') --> normalize.maxS (sublvl.union l l').

[t] lvl.imax (normalize.maxS sublvl.nil) t --> t.
[u, q, t] lvl.imax (normalize.maxS (sublvl.union (sublvl.singleton u) q)) t --> 
  lvl.max (normalize.rulehelper u t) (lvl.imax (normalize.maxS q) t).
