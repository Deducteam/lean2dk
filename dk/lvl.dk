Lvl: Type.

def z: Lvl.
def s: Lvl -> Lvl.
def max: Lvl -> Lvl -> Lvl.
def imax: Lvl -> Lvl -> Lvl.

Set: Type.
nil: Set.
singleton: Lvl -> Set.
defac union [Set].
def cons: Lvl -> Set -> Set.
[l, s] cons s l --> union (singleton s) l.




sSet: Type. (; set of sets type ;)
snil: sSet.
def scons: Set -> sSet -> sSet.

def sunion : Set -> sSet -> sSet. (; `sunion s l` is s unioned with each set in l ;)
[] sunion _ snil --> snil.
[s, s', l] sunion s (scons s' l) --> (scons (union s s') (sunion s l)).

def smerge : sSet -> sSet -> sSet.
[l] smerge snil l --> l.
[s, l, l'] smerge (scons s l) l' --> scons s (smerge l l').

def sunionboth : sSet -> sSet -> sSet.
[] sunionboth snil _ --> snil.
[s, l, l'] sunionboth (scons s l) l' --> smerge (sunion s l') (sunionboth l l').

multi: sSet -> Set.

[l, l'] scons (multi l') l --> smerge l' l.

def msunion : Set -> sSet -> Set.
[s, l] msunion s l --> multi (sunion s l).

[l, lvl] union (singleton lvl) (multi l) --> msunion (singleton lvl) l.
[l, s, s'] union (union s s') (multi l) --> msunion (union s s') l.
[l] union nil (multi l) --> msunion nil l.

[l, lvl] union (multi l) (singleton lvl) --> msunion (singleton lvl) l.
[l, s, s'] union (multi l) (union s s') --> msunion (union s s') l.
[l] union (multi l) nil --> msunion nil l.

[l, l'] union (multi l) (multi l') --> multi (sunionboth l l').




def iteset: bool.Bool -> Set -> Set -> Set.
[n] iteset bool.true n _ --> n.
[n] iteset bool.false _ n --> n.

[l, ls] union (singleton l) (union (singleton l) ls) --> (union (singleton l) ls).

def merge: Set -> Set -> Set.
[l] merge nil l --> l.
[l1, l2, n] merge (union (singleton n) l1) l2 --> cons n (merge l1 l2).

def subset: Set -> Set -> bool.Bool.
[] subset nil _ --> bool.true.
[n, q] subset (union (singleton n) q) nil --> bool.false
[n, q, q'] subset (union (singleton n) q) (union (singleton n) q') --> subset q q'.

def eqset: Set -> Set -> bool.Bool.
[l1, l2] eqset l1 l2 --> bool.and (subset l1 l2) (subset l2 l1).
